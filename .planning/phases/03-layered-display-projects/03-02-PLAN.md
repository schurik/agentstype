---
phase: 03-layered-display-projects
plan: 02
type: execute
wave: 2
depends_on: [03-01]
files_modified:
  - app/components/feed/EventCard.tsx
  - app/components/feed/ExpandedContent.tsx
  - app/components/ui/CodeBlock.tsx
  - app/lib/highlighter.ts
  - app/hooks/useExpandedEvents.ts
autonomous: true

must_haves:
  truths:
    - "Clicking an event card toggles expanded/collapsed state"
    - "Expanded state shows full tool inputs and outputs"
    - "Code content in expanded view has syntax highlighting"
    - "Expand/collapse animates smoothly"
    - "Multiple events can be expanded simultaneously"
    - "Rotating chevron indicates expand state"
  artifacts:
    - path: "app/components/feed/EventCard.tsx"
      provides: "Expandable event card with react-collapsed"
      min_lines: 50
    - path: "app/components/feed/ExpandedContent.tsx"
      provides: "Tailored layouts per event type (Read, Write, Bash, etc.)"
      min_lines: 80
    - path: "app/components/ui/CodeBlock.tsx"
      provides: "Shiki-powered syntax highlighting component"
      exports: ["CodeBlock"]
    - path: "app/lib/highlighter.ts"
      provides: "Shiki highlighter singleton"
      exports: ["highlighter", "highlight"]
  key_links:
    - from: "app/components/feed/EventCard.tsx"
      to: "react-collapsed"
      via: "useCollapse hook"
      pattern: "useCollapse"
    - from: "app/components/ui/CodeBlock.tsx"
      to: "app/lib/highlighter.ts"
      via: "highlight function import"
      pattern: "import.*highlighter"
---

<objective>
Implement expand/collapse functionality for EventCard with tailored expanded content layouts per event type and syntax highlighting.

Purpose: Enables progressive disclosure - users see summary by default, expand for full technical details including tool inputs, outputs, and syntax-highlighted code.
Output: Expandable EventCard, ExpandedContent with per-type layouts, CodeBlock with Shiki highlighting.
</objective>

<execution_context>
@/Users/alexander.buss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexander.buss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/03-layered-display-projects/03-RESEARCH.md
@.planning/phases/03-layered-display-projects/03-CONTEXT.md

# Existing files to modify
@app/components/feed/EventCard.tsx
@convex/schema.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create CodeBlock component and Shiki highlighter</name>
  <files>app/lib/highlighter.ts, app/components/ui/CodeBlock.tsx</files>
  <action>
1. Create app/lib/highlighter.ts:
   - Create singleton Shiki highlighter instance
   - Export async `highlight(code: string, lang: string)` function
   - Use 'github-dark' theme (matches dark mode design)
   - Handle unknown languages gracefully (fallback to 'text')
   - Cache the highlighter promise for reuse

```typescript
import { createHighlighter, type Highlighter } from 'shiki'

let highlighterPromise: Promise<Highlighter> | null = null

async function getHighlighter() {
  if (!highlighterPromise) {
    highlighterPromise = createHighlighter({
      themes: ['github-dark'],
      langs: ['typescript', 'javascript', 'json', 'bash', 'markdown', 'tsx', 'jsx', 'css', 'html', 'python', 'rust', 'go']
    })
  }
  return highlighterPromise
}

export async function highlight(code: string, lang: string): Promise<string> {
  const highlighter = await getHighlighter()
  const loadedLangs = highlighter.getLoadedLanguages()

  // Fallback to 'text' for unknown languages
  const language = loadedLangs.includes(lang) ? lang : 'text'

  return highlighter.codeToHtml(code, {
    lang: language,
    theme: 'github-dark'
  })
}
```

2. Create app/components/ui/CodeBlock.tsx:
   - Client component that renders highlighted code
   - Accept `code` and `lang` props
   - Use React.use() with highlight() for async rendering (or useEffect + state)
   - Add copy button that appears on hover
   - Apply monospace styling and subtle border

```typescript
'use client'

import { useState, useEffect } from 'react'
import { highlight } from '@/app/lib/highlighter'

interface CodeBlockProps {
  code: string
  lang?: string
}

export function CodeBlock({ code, lang = 'text' }: CodeBlockProps) {
  const [html, setHtml] = useState<string>('')
  const [copied, setCopied] = useState(false)

  useEffect(() => {
    highlight(code, lang).then(setHtml)
  }, [code, lang])

  const handleCopy = async () => {
    await navigator.clipboard.writeText(code)
    setCopied(true)
    setTimeout(() => setCopied(false), 2000)
  }

  if (!html) {
    return (
      <pre className="bg-zinc-900 p-3 rounded text-sm font-mono text-zinc-400 overflow-x-auto">
        <code>{code}</code>
      </pre>
    )
  }

  return (
    <div className="relative group">
      <button
        onClick={handleCopy}
        className="absolute top-2 right-2 px-2 py-1 text-xs bg-zinc-700 text-zinc-300 rounded opacity-0 group-hover:opacity-100 transition-opacity"
      >
        {copied ? 'Copied!' : 'Copy'}
      </button>
      <div
        className="bg-zinc-900 p-3 rounded text-sm overflow-x-auto [&_pre]:!bg-transparent [&_pre]:!p-0 [&_code]:!bg-transparent"
        dangerouslySetInnerHTML={{ __html: html }}
      />
    </div>
  )
}
```

Note: The CSS selectors override Shiki's default background to match our theme.
  </action>
  <verify>
- `ls app/lib/highlighter.ts app/components/ui/CodeBlock.tsx` shows both files exist
- `grep "createHighlighter" app/lib/highlighter.ts` confirms Shiki usage
- `bun run build` passes
  </verify>
  <done>Shiki highlighter singleton created; CodeBlock component renders syntax-highlighted code with copy button</done>
</task>

<task type="auto">
  <name>Task 2: Create ExpandedContent with tailored layouts per event type</name>
  <files>app/components/feed/ExpandedContent.tsx</files>
  <action>
Create app/components/feed/ExpandedContent.tsx with tailored layouts for each event type:

1. **Read events**: Show file content with syntax highlighting
   - Display file_path
   - Show content (toolResponse or toolInput.content) with CodeBlock
   - Detect language from file extension

2. **Write events**: Show new content written
   - Display file_path
   - Show content with syntax highlighting
   - No diff - just the new content per CONTEXT.md decision

3. **Edit events**: Show old_string -> new_string transformation
   - Display file_path
   - Show old_string (struck through or dimmed)
   - Show new_string with highlighting

4. **Bash events**: Terminal-style output
   - Show command in bold/green
   - Show stdout/stderr output in monospace
   - Style stderr differently (red text)

5. **Glob/Grep events**: List of matches
   - Show pattern/query
   - Show matching files/results as list

6. **Error events**: Error styling
   - Red border or background tint
   - Show error message prominently

Component structure:
```typescript
'use client'

import type { Doc } from '@/convex/_generated/dataModel'
import { CodeBlock } from '../ui/CodeBlock'

type Event = Doc<'events'>

interface ExpandedContentProps {
  event: Event
}

function getLanguageFromPath(path: string): string {
  const ext = path.split('.').pop()?.toLowerCase()
  const langMap: Record<string, string> = {
    ts: 'typescript', tsx: 'tsx', js: 'javascript', jsx: 'jsx',
    json: 'json', md: 'markdown', css: 'css', html: 'html',
    py: 'python', rs: 'rust', go: 'go', sh: 'bash'
  }
  return langMap[ext ?? ''] ?? 'text'
}

function ReadContent({ event }: { event: Event }) {
  const filePath = (event.toolInput as { file_path?: string })?.file_path
  const content = typeof event.toolResponse === 'string'
    ? event.toolResponse
    : JSON.stringify(event.toolResponse, null, 2)
  const lang = filePath ? getLanguageFromPath(filePath) : 'text'

  return (
    <div className="space-y-2">
      {filePath && (
        <div className="text-xs text-zinc-500 font-mono">{filePath}</div>
      )}
      <CodeBlock code={content || '(empty)'} lang={lang} />
    </div>
  )
}

function WriteContent({ event }: { event: Event }) {
  const input = event.toolInput as { file_path?: string; content?: string } | undefined
  const filePath = input?.file_path
  const content = input?.content
  const lang = filePath ? getLanguageFromPath(filePath) : 'text'

  return (
    <div className="space-y-2">
      {filePath && (
        <div className="text-xs text-zinc-500 font-mono">{filePath}</div>
      )}
      <CodeBlock code={content || '(empty)'} lang={lang} />
    </div>
  )
}

function EditContent({ event }: { event: Event }) {
  const input = event.toolInput as { file_path?: string; old_string?: string; new_string?: string } | undefined
  const filePath = input?.file_path
  const oldString = input?.old_string
  const newString = input?.new_string
  const lang = filePath ? getLanguageFromPath(filePath) : 'text'

  return (
    <div className="space-y-2">
      {filePath && (
        <div className="text-xs text-zinc-500 font-mono">{filePath}</div>
      )}
      {oldString && (
        <div>
          <div className="text-xs text-red-400 mb-1">- Removed:</div>
          <div className="opacity-60">
            <CodeBlock code={oldString} lang={lang} />
          </div>
        </div>
      )}
      {newString && (
        <div>
          <div className="text-xs text-green-400 mb-1">+ Added:</div>
          <CodeBlock code={newString} lang={lang} />
        </div>
      )}
    </div>
  )
}

function BashContent({ event }: { event: Event }) {
  const input = event.toolInput as { command?: string } | undefined
  const command = input?.command
  const output = typeof event.toolResponse === 'string'
    ? event.toolResponse
    : JSON.stringify(event.toolResponse, null, 2)

  return (
    <div className="space-y-2 font-mono text-sm">
      {command && (
        <div className="text-green-400">
          <span className="text-zinc-500">$</span> {command}
        </div>
      )}
      {output && (
        <pre className="text-zinc-300 whitespace-pre-wrap bg-zinc-900 p-2 rounded overflow-x-auto">
          {output}
        </pre>
      )}
    </div>
  )
}

function GlobGrepContent({ event }: { event: Event }) {
  const input = event.toolInput as { pattern?: string; path?: string } | undefined
  const pattern = input?.pattern
  const results = Array.isArray(event.toolResponse) ? event.toolResponse : []

  return (
    <div className="space-y-2">
      {pattern && (
        <div className="text-xs text-zinc-400">
          <span className="text-zinc-500">Pattern:</span> {pattern}
        </div>
      )}
      {results.length > 0 && (
        <ul className="text-sm font-mono text-zinc-300 space-y-1">
          {results.slice(0, 20).map((item, i) => (
            <li key={i} className="truncate">{typeof item === 'string' ? item : JSON.stringify(item)}</li>
          ))}
          {results.length > 20 && (
            <li className="text-zinc-500">...and {results.length - 20} more</li>
          )}
        </ul>
      )}
    </div>
  )
}

function ErrorContent({ event }: { event: Event }) {
  return (
    <div className="bg-red-950/30 border border-red-900/50 rounded p-3">
      <div className="text-red-400 text-sm font-mono">
        {event.error || 'Unknown error'}
      </div>
      {event.toolInput && (
        <details className="mt-2">
          <summary className="text-xs text-zinc-500 cursor-pointer">Tool Input</summary>
          <pre className="mt-1 text-xs text-zinc-400 overflow-x-auto">
            {JSON.stringify(event.toolInput, null, 2)}
          </pre>
        </details>
      )}
    </div>
  )
}

function DefaultContent({ event }: { event: Event }) {
  return (
    <div className="space-y-2 text-sm">
      {event.toolInput && (
        <div>
          <div className="text-xs text-zinc-500 mb-1">Input:</div>
          <pre className="bg-zinc-900 p-2 rounded text-zinc-400 overflow-x-auto text-xs">
            {JSON.stringify(event.toolInput, null, 2)}
          </pre>
        </div>
      )}
      {event.toolResponse && (
        <div>
          <div className="text-xs text-zinc-500 mb-1">Output:</div>
          <pre className="bg-zinc-900 p-2 rounded text-zinc-400 overflow-x-auto text-xs">
            {typeof event.toolResponse === 'string'
              ? event.toolResponse
              : JSON.stringify(event.toolResponse, null, 2)}
          </pre>
        </div>
      )}
    </div>
  )
}

export function ExpandedContent({ event }: ExpandedContentProps) {
  const tool = event.tool?.toLowerCase()

  // Error events
  if (event.type === 'post_tool_use_failure' || event.error) {
    return <ErrorContent event={event} />
  }

  // Tool-specific layouts
  switch (tool) {
    case 'read':
      return <ReadContent event={event} />
    case 'write':
      return <WriteContent event={event} />
    case 'edit':
      return <EditContent event={event} />
    case 'bash':
      return <BashContent event={event} />
    case 'glob':
    case 'grep':
      return <GlobGrepContent event={event} />
    default:
      return <DefaultContent event={event} />
  }
}
```
  </action>
  <verify>
- `ls app/components/feed/ExpandedContent.tsx` shows file exists
- `grep -c "function.*Content" app/components/feed/ExpandedContent.tsx` returns 7+ (one per type + default)
- `bun run build` passes
  </verify>
  <done>ExpandedContent component provides tailored layouts for Read, Write, Edit, Bash, Glob/Grep, Error, and default event types</done>
</task>

<task type="auto">
  <name>Task 3: Update EventCard with expand/collapse using react-collapsed</name>
  <files>app/components/feed/EventCard.tsx, app/hooks/useExpandedEvents.ts</files>
  <action>
1. Create app/hooks/useExpandedEvents.ts:
   - Track Set of expanded event IDs
   - Provide toggle, expandAll, collapseAll functions
   - Return { isExpanded(id), toggle(id), expandAll(ids), collapseAll() }

```typescript
'use client'

import { useState, useCallback } from 'react'

export function useExpandedEvents() {
  const [expandedIds, setExpandedIds] = useState<Set<string>>(new Set())

  const isExpanded = useCallback((id: string) => expandedIds.has(id), [expandedIds])

  const toggle = useCallback((id: string) => {
    setExpandedIds(prev => {
      const next = new Set(prev)
      if (next.has(id)) {
        next.delete(id)
      } else {
        next.add(id)
      }
      return next
    })
  }, [])

  const expandAll = useCallback((ids: string[]) => {
    setExpandedIds(new Set(ids))
  }, [])

  const collapseAll = useCallback(() => {
    setExpandedIds(new Set())
  }, [])

  return { isExpanded, toggle, expandAll, collapseAll, expandedCount: expandedIds.size }
}
```

2. Update app/components/feed/EventCard.tsx:
   - Add react-collapsed for smooth expand/collapse animation
   - Accept isExpanded and onToggle props (externally controlled)
   - Add rotating chevron indicator
   - Make entire card clickable (large touch target per CONTEXT.md)
   - Apply padding on inner element, not collapse container (per RESEARCH.md anti-pattern)
   - Add aria-expanded and aria-controls for accessibility

Updated EventCard implementation:
```typescript
'use client'

import { useRelativeTime } from './hooks/useRelativeTime'
import { useCollapse } from 'react-collapsed'
import { ExpandedContent } from './ExpandedContent'
import type { Doc } from '@/convex/_generated/dataModel'

type Event = Doc<'events'>

// ... keep borderColors and truncatePath from existing code ...

interface EventCardProps {
  event: Event
  isNew?: boolean
  isExpanded: boolean
  onToggle: () => void
}

export function EventCard({ event, isNew = false, isExpanded, onToggle }: EventCardProps) {
  const { getCollapseProps, getToggleProps } = useCollapse({
    isExpanded,
    duration: 200,
    easing: 'cubic-bezier(0.4, 0, 0.2, 1)',
  })

  // ... existing borderClass, filePath, animationClass, label logic ...

  return (
    <div
      {...getToggleProps({
        onClick: onToggle,
        'aria-expanded': isExpanded,
        'aria-controls': `event-content-${event._id}`,
      })}
      className={`border-l-4 ${borderClass} bg-zinc-900/50 cursor-pointer hover:bg-zinc-900/70 transition-colors ${animationClass}`}
    >
      {/* Summary row */}
      <div className="flex items-center justify-between gap-2 px-3 py-2">
        <div className="flex items-center gap-2 min-w-0">
          {/* Chevron indicator */}
          <svg
            className={`w-4 h-4 text-zinc-500 transition-transform duration-200 ${isExpanded ? 'rotate-90' : ''}`}
            fill="none"
            viewBox="0 0 24 24"
            stroke="currentColor"
          >
            <path strokeLinecap="round" strokeLinejoin="round" strokeWidth={2} d="M9 5l7 7-7 7" />
          </svg>
          <span className="font-mono text-sm text-zinc-300 shrink-0">{label}</span>
          {filePath && (
            <span className="font-mono text-xs text-zinc-500 truncate">
              {truncatePath(filePath)}
            </span>
          )}
        </div>
        <Timestamp value={event.timestamp} />
      </div>

      {/* Expandable content */}
      <div {...getCollapseProps()} id={`event-content-${event._id}`} aria-hidden={!isExpanded}>
        <div className="px-3 pb-3 pt-1 border-t border-zinc-800">
          <ExpandedContent event={event} />
        </div>
      </div>
    </div>
  )
}
```

Note: isExpanded and onToggle are now required props - EventFeed will manage the state via useExpandedEvents hook.
  </action>
  <verify>
- `grep "useCollapse" app/components/feed/EventCard.tsx` confirms react-collapsed usage
- `grep "useExpandedEvents" app/hooks/useExpandedEvents.ts` confirms hook exists
- `bun run build` passes
  </verify>
  <done>EventCard expands/collapses on click with smooth animation; chevron rotates; multiple cards can be expanded simultaneously</done>
</task>

</tasks>

<verification>
1. CodeBlock renders syntax-highlighted code with copy button
2. ExpandedContent shows tailored layout based on event type
3. EventCard expands/collapses with smooth animation on click
4. Multiple events can be expanded at the same time
5. `bun run build` passes
</verification>

<success_criteria>
- Clicking event card toggles expanded/collapsed state
- Expanded view shows full tool inputs and outputs
- Code content has syntax highlighting (Shiki)
- Expand/collapse has smooth slide animation
- Chevron rotates to indicate state
- Multiple events can be expanded simultaneously
- Build passes without errors
</success_criteria>

<output>
After completion, create `.planning/phases/03-layered-display-projects/03-02-SUMMARY.md`
</output>
