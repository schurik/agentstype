---
phase: 01-event-capture-infrastructure
plan: 01
type: execute
wave: 1
depends_on: []
files_modified:
  - convex/schema.ts
  - convex/events.ts
  - convex/http.ts
autonomous: true

must_haves:
  truths:
    - "HTTP POST to /event stores event in Convex database"
    - "Events are queryable by project name"
    - "Events are queryable by session ID"
    - "Frontend can subscribe to events in real-time via Convex query"
  artifacts:
    - path: "convex/schema.ts"
      provides: "Events table with indexes"
      contains: "events: defineTable"
    - path: "convex/events.ts"
      provides: "Internal mutation for storing events and query for frontend subscription"
      exports: ["store", "listEvents"]
    - path: "convex/http.ts"
      provides: "HTTP endpoint for receiving events"
      contains: "httpRouter"
  key_links:
    - from: "convex/http.ts"
      to: "convex/events.ts"
      via: "runMutation call"
      pattern: "ctx\\.runMutation.*events\\.store"
    - from: "frontend (useQuery)"
      to: "convex/events.ts"
      via: "Convex subscription"
      pattern: "export const listEvents = query"
---

<objective>
Create the Convex backend that receives and stores Claude Code events.

Purpose: Establish the receiving end of the event pipeline. The hook will POST events to this endpoint, and Convex will store them for real-time subscription by the frontend.

Output: A working Convex HTTP endpoint at /event that accepts POSTed events and persists them to the events table.
</objective>

<execution_context>
@/Users/alexander.buss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexander.buss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-event-capture-infrastructure/01-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create events schema with indexes</name>
  <files>convex/schema.ts</files>
  <action>
Create the Convex schema with an events table. The schema must support:

**Required fields:**
- `eventId` (string): Unique identifier for the event
- `sessionId` (string): Claude Code session ID
- `projectName` (string): Derived from cwd folder name
- `type` (string): Event type (pre_tool_use, post_tool_use, session_start, session_end, user_prompt_submit, stop, notification)
- `timestamp` (number): Unix timestamp in milliseconds

**Optional fields (depend on event type):**
- `tool` (optional string): Tool name for tool events
- `toolInput` (optional any): Tool input JSON
- `toolOutput` (optional any): Tool output JSON (for post_tool_use)
- `prompt` (optional string): User prompt (for user_prompt_submit)
- `response` (optional string): Claude response (for stop events)
- `cwd` (optional string): Working directory path
- `redacted` (optional boolean): True if secrets were filtered

**Indexes (for efficient queries):**
- `by_project`: [projectName, timestamp] - Query events by project
- `by_session`: [sessionId, timestamp] - Query events by session

Follow Convex schema conventions using defineSchema, defineTable, and v validators.
  </action>
  <verify>Run `bunx convex dev --once` - should succeed without schema errors</verify>
  <done>Schema file exists with events table definition and both indexes</done>
</task>

<task type="auto">
  <name>Task 2: Create HTTP endpoint and event mutation</name>
  <files>convex/events.ts, convex/http.ts</files>
  <action>
Create two files:

**convex/events.ts** - Internal mutation for storing events:
- Create `store` as an internalMutation (not exposed to clients)
- Accept event fields matching the schema
- Insert into events table
- Generate eventId server-side if not provided (use crypto.randomUUID or similar)
- Return the inserted event ID

**convex/http.ts** - HTTP router with /event endpoint:
- Create httpRouter
- Add POST /event route using httpAction
- Parse JSON body from request
- Call internal events.store mutation
- Return 200 on success
- Return 200 even on error (don't trigger retries from hook)
- Log errors to console for debugging

Use the pattern from RESEARCH.md:
```typescript
http.route({
  path: "/event",
  method: "POST",
  handler: httpAction(async (ctx, request) => {
    try {
      const event = await request.json();
      await ctx.runMutation(internal.events.store, event);
      return new Response(null, { status: 200 });
    } catch (error) {
      console.error("Event storage failed:", error);
      return new Response(null, { status: 200 });
    }
  }),
});
```

Export http as default from http.ts.
  </action>
  <verify>
1. Run `bunx convex dev --once` - should deploy successfully
2. Get deployment URL from Convex dashboard or `npx convex env get CONVEX_URL`
3. Test with curl: `curl -X POST https://YOUR-DEPLOYMENT.convex.site/event -H "Content-Type: application/json" -d '{"sessionId":"test","projectName":"test","type":"session_start","timestamp":1234567890}'`
4. Should return 200
  </verify>
  <done>HTTP endpoint accepts POST requests and stores events in database</done>
</task>

<task type="auto">
  <name>Task 3: Create listEvents query for real-time frontend subscription</name>
  <files>convex/events.ts</files>
  <action>
Add a `listEvents` query function to convex/events.ts that enables real-time frontend subscriptions.

**Function signature:**
- Export as a public `query` (not internalQuery) so frontend can subscribe via `useQuery(api.events.listEvents)`
- Accept optional filters: `projectName?: string`, `sessionId?: string`, `limit?: number`

**Implementation:**
- Default `limit` to 100 most recent events
- If `projectName` is provided, use the `by_project` index and filter by projectName
- If `sessionId` is provided, use the `by_session` index and filter by sessionId
- If neither filter is provided, return most recent events across all projects
- Order results by timestamp DESC (most recent first)
- Return array of event documents

**Example usage:**
```typescript
// In frontend component:
const events = useQuery(api.events.listEvents, { projectName: "myproject", limit: 50 });
```

This query enables Convex's real-time subscription - when new events are stored, any subscribed frontend will automatically receive updates.
  </action>
  <verify>
1. Run `bunx convex dev --once` - should deploy successfully
2. In Convex dashboard, verify the listEvents function appears in the Functions tab
3. Test query in dashboard: call listEvents with no args, should return empty array or stored test events
4. Test with projectName filter: should only return events matching that project
  </verify>
  <done>listEvents query is exported and queryable, frontend can subscribe to real-time event updates via useQuery</done>
</task>

</tasks>

<verification>
After all tasks complete:

1. Schema validation:
   - `bunx convex dev --once` runs without errors

2. HTTP endpoint test:
   - POST a test event to the endpoint
   - Query the database in Convex dashboard to see the stored event

3. Index verification:
   - Events table has by_project and by_session indexes visible in dashboard

4. Query function test:
   - Call listEvents in Convex dashboard with no filters - should return stored events
   - Call listEvents with projectName filter - should return filtered results
   - Verify listEvents appears in api.events exports for frontend subscription
</verification>

<success_criteria>
- convex/schema.ts defines events table with all required fields
- convex/events.ts exports internal store mutation
- convex/events.ts exports public listEvents query for frontend subscription
- convex/http.ts exposes POST /event endpoint
- Test POST request stores event in database
- Both indexes are created and usable
- Frontend can subscribe to events via useQuery(api.events.listEvents)
</success_criteria>

<output>
After completion, create `.planning/phases/01-event-capture-infrastructure/01-01-SUMMARY.md`
</output>
