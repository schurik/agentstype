---
phase: 01-event-capture-infrastructure
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - .claude/hooks/agentstype-hook.sh
  - .agentstype.json
autonomous: true

must_haves:
  truths:
    - "Hook captures events and POSTs to configured Convex URL"
    - "Sensitive data (API keys, tokens, passwords) is redacted before POST"
    - "Hook only fires in directories with .agentstype.json"
    - "Project name is derived from cwd or config override"
  artifacts:
    - path: ".claude/hooks/agentstype-hook.sh"
      provides: "Claude Code hook script"
      min_lines: 150
    - path: ".agentstype.json"
      provides: "Project opt-in config"
      contains: "convexUrl"
  key_links:
    - from: ".claude/hooks/agentstype-hook.sh"
      to: ".agentstype.json"
      via: "config file check"
      pattern: "\\.agentstype\\.json"
    - from: ".claude/hooks/agentstype-hook.sh"
      to: "convex HTTP endpoint"
      via: "curl POST"
      pattern: "curl.*POST"
---

<objective>
Create the Claude Code hook that captures events, filters secrets, and POSTs to Convex.

Purpose: This is the event capture engine. It runs locally on the developer's machine, intercepts Claude Code lifecycle events, filters sensitive data, and broadcasts to Convex for the live feed.

Output: A fully functional hook script that captures all event types, redacts secrets, and sends events to the configured Convex endpoint.
</objective>

<execution_context>
@/Users/alexander.buss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexander.buss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-event-capture-infrastructure/01-RESEARCH.md
@.planning/phases/01-event-capture-infrastructure/01-CONTEXT.md
@vibecraft-hook.sh
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create the agentstype hook script</name>
  <files>.claude/hooks/agentstype-hook.sh</files>
  <action>
Create the hook script at `.claude/hooks/agentstype-hook.sh`. Use vibecraft-hook.sh as a reference for structure and cross-platform compatibility.

**Required sections:**

1. **PATH Setup** (copy from vibecraft-hook.sh):
   - Add known tool locations to PATH
   - Find jq and curl with fallbacks

2. **Opt-In Check**:
   - Read cwd from stdin JSON
   - Check if `$cwd/.agentstype.json` exists
   - Exit 0 silently if config missing (not an agentstype project)

3. **Config Loading**:
   - Read `.agentstype.json` from cwd
   - Extract `convexUrl` (required - exit if missing)
   - Extract `projectName` (optional - default to `basename "$cwd"`)

4. **Event Parsing**:
   - Read JSON from stdin into variable
   - Extract: hook_event_name, session_id, cwd
   - Generate timestamp (use vibecraft-hook.sh macOS/Linux pattern)
   - Generate event_id (session_id + timestamp + random)

5. **Secret Filtering Function** `filter_secrets()`:
   Apply these regex patterns (from RESEARCH.md):
   ```
   # AWS Access Key
   AKIA[0-9A-Z]{16} -> [REDACTED_AWS_KEY]

   # GitHub tokens
   ghp_[0-9a-zA-Z]{36} -> [REDACTED_GITHUB_TOKEN]
   gho_[0-9a-zA-Z]{36} -> [REDACTED_GITHUB_TOKEN]

   # Google API Key
   AIza[0-9A-Za-z\-_]{35} -> [REDACTED_GOOGLE_KEY]

   # Slack tokens
   xox[pboa]-[0-9]{12}-[0-9]{12}-[0-9a-zA-Z]{24} -> [REDACTED_SLACK_TOKEN]

   # Generic secret patterns (case insensitive)
   password\s*[=:]\s*["']?[^\s"']{8,} -> [REDACTED_PASSWORD]
   token\s*[=:]\s*["']?[^\s"']{20,} -> [REDACTED_TOKEN]
   secret\s*[=:]\s*["']?[^\s"']{20,} -> [REDACTED_SECRET]
   api[_-]?key\s*[=:]\s*["']?[^\s"']{20,} -> [REDACTED_API_KEY]

   # Private keys
   -----BEGIN.*PRIVATE KEY----- -> [REDACTED_PRIVATE_KEY]
   ```
   - Return filtered content
   - Set a flag if any redaction occurred

6. **File Blocklist Function** `should_block_file()`:
   Block contents for these files/extensions:
   - Files: .env, .env.local, .env.production, credentials.json, secrets.json
   - Extensions: .pem, .key, .p12, .pfx
   - Return "[FILE BLOCKED]" for blocked files

7. **Event Type Mapping** (same as vibecraft-hook.sh):
   - PreToolUse -> pre_tool_use
   - PostToolUse -> post_tool_use
   - SessionStart -> session_start
   - SessionEnd -> session_end
   - UserPromptSubmit -> user_prompt_submit
   - Stop -> stop
   - Notification -> notification
   - etc.

8. **Event JSON Construction** by type:
   For each event type, build JSON with:
   - Common: eventId, sessionId, projectName, type, timestamp, cwd
   - Type-specific fields (tool, toolInput, toolOutput, prompt, response, etc.)
   - Apply `filter_secrets()` to ALL string content
   - Set `redacted: true` if filtering occurred

9. **Fire-and-Forget POST**:
   ```bash
   if [ -n "$CURL" ]; then
     "$CURL" -s -X POST "$CONVEX_URL/event" \
       -H "Content-Type: application/json" \
       -d "$event_json" \
       --connect-timeout 1 \
       --max-time 2 \
       >/dev/null 2>&1 &
   fi
   ```

10. **Exit**:
    - Always `exit 0` (never fail)

Make the script executable: `chmod +x .claude/hooks/agentstype-hook.sh`
  </action>
  <verify>
1. Script is executable: `ls -la .claude/hooks/agentstype-hook.sh` shows -rwx
2. Script passes shellcheck: `shellcheck .claude/hooks/agentstype-hook.sh` (if available)
3. Script can be parsed: `bash -n .claude/hooks/agentstype-hook.sh` returns 0
4. Test secret filtering manually:
   ```bash
   echo "key: AKIAIOSFODNN7EXAMPLE test" | source .claude/hooks/agentstype-hook.sh 2>/dev/null
   # Note: This won't work directly, but the filter_secrets function should be testable
   ```
  </verify>
  <done>Hook script exists, is executable, handles all event types, filters secrets</done>
</task>

<task type="auto">
  <name>Task 2: Create project config and installation docs</name>
  <files>.agentstype.json</files>
  <action>
**Create `.agentstype.json`** in the project root:

```json
{
  "projectName": "agentstype",
  "convexUrl": "https://YOUR_DEPLOYMENT.convex.site"
}
```

Note: The convexUrl will be placeholder until Convex is deployed. After 01-01 completes and Convex is deployed, update this with the actual URL.

**Add hook installation to .claude/settings.json** (create if doesn't exist):

The Claude Code settings file should include:
```json
{
  "hooks": {
    "PreToolUse": [".claude/hooks/agentstype-hook.sh"],
    "PostToolUse": [".claude/hooks/agentstype-hook.sh"],
    "SessionStart": [".claude/hooks/agentstype-hook.sh"],
    "SessionEnd": [".claude/hooks/agentstype-hook.sh"],
    "UserPromptSubmit": [".claude/hooks/agentstype-hook.sh"],
    "Stop": [".claude/hooks/agentstype-hook.sh"],
    "Notification": [".claude/hooks/agentstype-hook.sh"]
  }
}
```

If .claude/settings.json already exists, merge the hooks configuration.
  </action>
  <verify>
1. `.agentstype.json` exists and is valid JSON: `jq . .agentstype.json`
2. `.claude/settings.json` exists and hooks are configured: `jq '.hooks' .claude/settings.json`
3. Verify hook paths are correct: `ls -la .claude/hooks/agentstype-hook.sh`
  </verify>
  <done>Config file marks project as opt-in, hooks are registered in settings.json</done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Hook script structure:
   - PATH setup section exists
   - Opt-in check for .agentstype.json
   - Secret filtering function with all patterns
   - File blocklist function
   - Event type mapping for all types
   - Fire-and-forget curl POST

2. Config files:
   - .agentstype.json is valid JSON with projectName and convexUrl
   - .claude/settings.json registers hook for all event types

3. Integration test (after 01-01 completes):
   - Run a simple Claude Code command in this project
   - Check Convex dashboard for the event
   - Verify projectName is "agentstype"
   - Verify no secrets leaked (if any were in the command output)
</verification>

<success_criteria>
- Hook script captures all Claude Code event types
- Secret patterns are redacted before transmission
- File blocklist prevents sensitive file contents from being sent
- Project name derived from cwd folder name
- Config file provides Convex URL
- Hooks registered in .claude/settings.json
- Fire-and-forget POST doesn't block Claude workflow
</success_criteria>

<output>
After completion, create `.planning/phases/01-event-capture-infrastructure/01-02-SUMMARY.md`
</output>
