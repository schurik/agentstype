---
phase: 02-core-feed-display
plan: 02
type: execute
wave: 2
depends_on: ["02-01"]
files_modified:
  - app/components/feed/EventCard.tsx
  - app/components/feed/ConnectionStatus.tsx
  - app/components/feed/NewEventsIndicator.tsx
  - app/components/ui/Header.tsx
  - app/components/feed/EventFeed.tsx
autonomous: true

must_haves:
  truths:
    - "Event cards show colored left border based on event type"
    - "Event cards show event type label and relative timestamp"
    - "Hovering timestamp shows absolute time"
    - "Connection status shows green pulsing dot for Live"
    - "Connection status shows yellow/red dot for Reconnecting/Offline"
    - "New events badge appears when user scrolls up"
    - "Feed auto-scrolls to new events when user is at bottom"
  artifacts:
    - path: "app/components/feed/EventCard.tsx"
      provides: "Individual event display with colored border and timestamp"
      exports: ["EventCard"]
    - path: "app/components/feed/ConnectionStatus.tsx"
      provides: "Live/Reconnecting/Offline/Idle status indicator"
      exports: ["ConnectionStatus"]
    - path: "app/components/feed/NewEventsIndicator.tsx"
      provides: "Floating badge showing new event count"
      exports: ["NewEventsIndicator"]
    - path: "app/components/ui/Header.tsx"
      provides: "Header bar with title and connection status"
      exports: ["Header"]
    - path: "app/components/feed/EventFeed.tsx"
      provides: "Main feed container with real-time subscription"
      exports: ["EventFeed"]
  key_links:
    - from: "app/components/feed/EventCard.tsx"
      to: "app/components/feed/hooks/useRelativeTime.ts"
      via: "import and use for timestamp"
      pattern: "useRelativeTime"
    - from: "app/components/feed/ConnectionStatus.tsx"
      to: "app/components/feed/hooks/useConnectionStatus.ts"
      via: "import and use for status"
      pattern: "useConnectionStatus"
    - from: "app/components/feed/EventFeed.tsx"
      to: "convex/_generated/api"
      via: "useQuery subscription"
      pattern: "useQuery\\(api\\.events\\.listEvents"
    - from: "app/components/feed/EventFeed.tsx"
      to: "app/components/feed/hooks/useAutoScroll.ts"
      via: "import and use for scroll behavior"
      pattern: "useAutoScroll"
---

<objective>
Create the visual components for the event feed: EventCard, ConnectionStatus, Header, NewEventsIndicator, and EventFeed.

Purpose: Build all the UI components that display events, connection status, and handle the real-time feed behavior. These components use the hooks from Plan 01.

Output: Complete set of feed components ready to be composed into the main page in Plan 03.
</objective>

<execution_context>
@/Users/alexander.buss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexander.buss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/02-core-feed-display/02-CONTEXT.md
@.planning/phases/02-core-feed-display/02-RESEARCH.md
@convex/schema.ts
@convex/events.ts
@app/components/feed/hooks/useConnectionStatus.ts
@app/components/feed/hooks/useRelativeTime.ts
@app/components/feed/hooks/useAutoScroll.ts
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create EventCard component with colored borders and timestamps</name>
  <files>app/components/feed/EventCard.tsx</files>
  <action>
Create EventCard.tsx as a client component:

1. "use client" directive at top

2. Import useRelativeTime from hooks

3. Define Event type matching Convex schema (or import from convex/_generated/dataModel if available):
   - Required: _id, eventId, sessionId, projectName, type, timestamp
   - Optional: tool, toolInput, toolResponse, error, etc.

4. Create borderColors map for event type distinction:
   - Read tool: "border-l-green-500" (green)
   - Write tool: "border-l-blue-500" (blue)
   - Bash tool: "border-l-orange-500" (orange)
   - post_tool_use_failure / error types: "border-l-red-500" (red)
   - Default fallback: "border-l-zinc-600"

5. Create Timestamp subcomponent:
   - Use useRelativeTime hook with event.timestamp
   - Wrap in <time> element with dateTime attribute
   - Add title attribute with absolute time for hover
   - Style: "text-xs text-zinc-500 cursor-default"

6. Create truncatePath helper:
   - If path <= 40 chars, return as-is
   - Otherwise: first part + "/.../" + last part
   - Example: "src/components/very/long/path/Component.tsx" -> "src/.../Component.tsx"

7. EventCard component:
   - Props: { event: Event, isNew?: boolean }
   - Determine border color from event.tool ?? event.type
   - Apply animation class only if isNew: "animate-in fade-in slide-in-from-bottom-2 duration-300"
   - Terminal-like density: minimal padding (px-3 py-2)
   - Background: bg-zinc-900/50
   - Show:
     - Event label (tool name or event type) in font-mono text-sm text-zinc-300
     - If tool is Read/Write and toolInput has file_path: show truncated path
     - Timestamp in top-right corner
  </action>
  <verify>
- `bunx tsc --noEmit` passes
- File exports EventCard component
- Component uses useRelativeTime hook
- Border colors defined for Read, Write, Bash, error types
  </verify>
  <done>EventCard component renders event with colored border, truncated path, relative timestamp with hover absolute time</done>
</task>

<task type="auto">
  <name>Task 2: Create ConnectionStatus, NewEventsIndicator, and Header components</name>
  <files>
    app/components/feed/ConnectionStatus.tsx
    app/components/feed/NewEventsIndicator.tsx
    app/components/ui/Header.tsx
  </files>
  <action>
**ConnectionStatus.tsx:**
1. "use client" directive
2. Import useConnectionStatus hook
3. Create config object mapping status to styling:
   - live: green-500 pulsing dot + "Live" text
   - reconnecting: yellow-500 dot + "Reconnecting..." text
   - offline: red-500 dot + "Offline" text
   - idle: zinc-500 dot + "Idle" text
4. Render:
   - Container: flex items-center gap-2
   - Dot: h-2 w-2 rounded-full with status color, animate-pulse for live
   - Text: text-sm text-zinc-400

**NewEventsIndicator.tsx:**
1. "use client" directive
2. Props: { count: number, onClick: () => void }
3. Only render if count > 0
4. Floating badge style: fixed positioning near bottom center
5. Style: bg-zinc-800 border border-zinc-700 rounded-full px-4 py-2 shadow-lg
6. Content: "{count} new event{s} â†“" with cursor-pointer
7. Animate in: animate-in fade-in slide-in-from-bottom-4

**Header.tsx:**
1. "use client" directive
2. Import ConnectionStatus component
3. Props: { newEventCount?: number } (to show in header when paused)
4. Full-width header bar: sticky top-0, bg-zinc-950, border-b border-zinc-800
5. Content:
   - Left: Title "agentstype.dev" in font-mono font-semibold
   - Right: ConnectionStatus + optional new event count badge
6. Padding: px-4 py-3, z-10 for stacking
  </action>
  <verify>
- `bunx tsc --noEmit` passes
- All three files export their components
- ConnectionStatus uses useConnectionStatus hook
- Header includes ConnectionStatus
  </verify>
  <done>ConnectionStatus shows live/reconnecting/offline with colored dots, NewEventsIndicator floats at bottom, Header contains title and status</done>
</task>

<task type="auto">
  <name>Task 3: Create EventFeed component with real-time subscription and auto-scroll</name>
  <files>app/components/feed/EventFeed.tsx</files>
  <action>
Create EventFeed.tsx as the main feed container:

1. "use client" directive

2. Imports:
   - useQuery from "convex/react"
   - api from "@/convex/_generated/api"
   - EventCard from "./EventCard"
   - NewEventsIndicator from "./NewEventsIndicator"
   - useAutoScroll from "./hooks/useAutoScroll"
   - useRef, useState, useEffect from "react"

3. Track initial load to distinguish new events:
   - const [initialEventIds, setInitialEventIds] = useState<Set<string>>(new Set())
   - const [hasInitialLoad, setHasInitialLoad] = useState(false)
   - On first non-undefined events, capture their IDs and set hasInitialLoad

4. Subscribe to events:
   - const events = useQuery(api.events.listEvents, { limit: 100 })
   - Handle undefined (loading state): show skeleton or loading spinner

5. Use auto-scroll hook:
   - Pass events array and initial load size
   - Destructure: bottomRef, sentinelRef, newItemCount, scrollToBottom, isAtBottom

6. Render structure:
   ```
   <div className="flex flex-col h-full overflow-hidden">
     <div className="flex-1 overflow-y-auto px-4 py-2 space-y-1">
       {events?.map((event) => (
         <EventCard
           key={event._id}
           event={event}
           isNew={hasInitialLoad && !initialEventIds.has(event._id)}
         />
       ))}
       <div ref={sentinelRef} className="h-1" />
       <div ref={bottomRef} />
     </div>
     <NewEventsIndicator count={newItemCount} onClick={scrollToBottom} />
   </div>
   ```

7. Loading state:
   - If events === undefined, show centered loading indicator
   - Use animate-pulse on skeleton cards

8. Empty state:
   - If events.length === 0, show "No events yet" message
   - Subtle styling: text-zinc-500 text-center py-8

9. Note: Events are returned DESC (newest first) from Convex, so newest appears at top.
   For a chat-like feed where newest is at bottom, reverse the array before mapping.
  </action>
  <verify>
- `bunx tsc --noEmit` passes
- File exports EventFeed component
- Component uses useQuery with api.events.listEvents
- Component uses useAutoScroll hook
- NewEventsIndicator rendered with correct props
  </verify>
  <done>EventFeed subscribes to real-time events, displays loading/empty states, renders EventCards with animation for new items, auto-scrolls when at bottom, shows new event count when scrolled up</done>
</task>

</tasks>

<verification>
After all tasks complete:
1. `bun run build` passes
2. All five component files exist and export correctly
3. EventCard has border colors for different event types
4. ConnectionStatus displays status with colored dot
5. EventFeed subscribes to Convex query
</verification>

<success_criteria>
- EventCard shows event type with colored left border (green=read, blue=write, orange=bash, red=error)
- EventCard shows relative timestamp that displays absolute on hover
- ConnectionStatus shows appropriate status with pulsing dot for Live
- NewEventsIndicator appears when user scrolls up and new events arrive
- EventFeed auto-scrolls to new events when user is at bottom
- Loading and empty states handled gracefully
</success_criteria>

<output>
After completion, create `.planning/phases/02-core-feed-display/02-02-SUMMARY.md`
</output>
