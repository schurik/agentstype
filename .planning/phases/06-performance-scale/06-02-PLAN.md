---
phase: 06-performance-scale
plan: 02
type: execute
wave: 1
depends_on: []
files_modified:
  - app/hooks/useEventFilter.ts
  - app/hooks/useBatchedEvents.ts
  - app/components/feed/FilterBar.tsx
autonomous: true

must_haves:
  truths:
    - "Events can be filtered by type via URL parameter"
    - "Consecutive same-type events from same agent are batched"
    - "Pre/post tool events with same toolUseId are grouped as single unit"
    - "Filter bar shows available event types with toggle buttons"
  artifacts:
    - path: "app/hooks/useEventFilter.ts"
      provides: "URL-synced event type filter state"
      exports: ["useEventFilter"]
    - path: "app/hooks/useBatchedEvents.ts"
      provides: "Event batching transformation"
      exports: ["useBatchedEvents", "BatchedEvent"]
    - path: "app/components/feed/FilterBar.tsx"
      provides: "Filter toggle UI"
      exports: ["FilterBar"]
  key_links:
    - from: "app/hooks/useEventFilter.ts"
      to: "nuqs"
      via: "parseAsArrayOf"
      pattern: "parseAsArrayOf.*parseAsString"
    - from: "app/hooks/useBatchedEvents.ts"
      to: "events"
      via: "toolUseId grouping then tool batching"
      pattern: "toolUseId"
---

<objective>
Create event batching and filtering hooks, plus the FilterBar component for event type selection.

Purpose: Enable information density through batching ("Read 15 files") and allow users to filter by event type.
Output: useBatchedEvents hook that transforms events into batched groups, useEventFilter hook for URL state, FilterBar component for UI.
</objective>

<execution_context>
@/Users/alexander.buss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexander.buss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-performance-scale/06-CONTEXT.md
@.planning/phases/06-performance-scale/06-RESEARCH.md
@convex/schema.ts
@app/hooks/useProjectFilter.ts
@app/components/feed/EventCard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create event filter and batching hooks</name>
  <files>app/hooks/useEventFilter.ts, app/hooks/useBatchedEvents.ts</files>
  <action>
**app/hooks/useEventFilter.ts:**
Create URL-synced filter for event types using nuqs:

```typescript
"use client";

import { useQueryState, parseAsArrayOf, parseAsString } from "nuqs";

/**
 * URL-synced event type filter.
 * State persists in URL as ?filter=Read,Write,Bash
 * Empty array = show all events (no filtering)
 */
export function useEventFilter() {
  return useQueryState(
    "filter",
    parseAsArrayOf(parseAsString).withDefault([])
  );
}
```

**app/hooks/useBatchedEvents.ts:**
Create batching transformation hook following CONTEXT.md decisions:

```typescript
"use client";

import { useMemo } from "react";
import type { Doc, Id } from "@/convex/_generated/dataModel";

type Event = Doc<"events">;

export interface BatchedEvent {
  /** Unique ID for React key - use first event's _id */
  id: Id<"events">;
  /** 'single' for individual events, 'batch' for grouped events */
  type: "single" | "batch";
  /** All events in this batch (1 for single, 2+ for batch) */
  events: Event[];
  /** Tool type (Read, Write, etc.) - null for non-tool events */
  tool: string | null;
  /** Agent ID - null for events without agent */
  agentId: string | null;
  /** Number of events in batch */
  count: number;
  /** Timestamp of first event (for ordering) */
  timestamp: number;
}

// Tools that should be batched when consecutive
const BATCHABLE_TOOLS = ["Read", "Glob", "Grep", "WebSearch", "WebFetch"];

// Minimum events to form a batch (per CONTEXT.md: 2+ triggers batching)
const MIN_BATCH_SIZE = 2;

/**
 * Transform events into batched groups for display.
 *
 * Per CONTEXT.md decisions:
 * 1. First pass: Group pre/post events by toolUseId
 * 2. Second pass: Batch consecutive same-tool, same-agent events
 * 3. Batch only BATCHABLE_TOOLS (read-heavy operations)
 * 4. Never cross agent boundaries
 */
export function useBatchedEvents(
  events: Event[] | undefined,
  filters: string[] = []
): BatchedEvent[] {
  return useMemo(() => {
    if (!events) return [];

    // Apply filters if any
    let filtered = events;
    if (filters.length > 0) {
      filtered = events.filter((e) => {
        const eventType = e.tool ?? e.type;
        return filters.includes(eventType);
      });
    }

    // Pass 1: Group pre/post events by toolUseId
    // This prevents "Read" followed by "Read (success)" showing separately
    const toolUseGroups = new Map<string, Event[]>();
    const standaloneEvents: Event[] = [];

    for (const event of filtered) {
      if (event.toolUseId) {
        const group = toolUseGroups.get(event.toolUseId) || [];
        group.push(event);
        toolUseGroups.set(event.toolUseId, group);
      } else {
        standaloneEvents.push(event);
      }
    }

    // Convert toolUseId groups to single logical events
    // Use the post_tool_use event as representative (has result), or first event
    const logicalEvents: Event[] = [];
    for (const [, group] of toolUseGroups) {
      // Sort by timestamp
      group.sort((a, b) => a.timestamp - b.timestamp);
      // Prefer post_tool_use (has result) over pre_tool_use
      const representative =
        group.find((e) => e.type === "post_tool_use") ||
        group.find((e) => e.type === "post_tool_use_failure") ||
        group[0];
      logicalEvents.push(representative);
    }
    logicalEvents.push(...standaloneEvents);

    // Sort DESC (newest first) to match feed display
    logicalEvents.sort((a, b) => b.timestamp - a.timestamp);

    // Pass 2: Batch consecutive same-tool, same-agent events
    const batched: BatchedEvent[] = [];
    let currentBatch: Event[] = [];
    let currentTool: string | null = null;
    let currentAgent: string | null = null;

    const flushBatch = () => {
      if (currentBatch.length === 0) return;

      if (currentBatch.length >= MIN_BATCH_SIZE) {
        // Create batch
        batched.push({
          id: currentBatch[0]._id,
          type: "batch",
          events: [...currentBatch],
          tool: currentTool,
          agentId: currentAgent,
          count: currentBatch.length,
          timestamp: currentBatch[0].timestamp,
        });
      } else {
        // Not enough for batch - add as singles
        for (const event of currentBatch) {
          batched.push({
            id: event._id,
            type: "single",
            events: [event],
            tool: event.tool ?? null,
            agentId: event.agentId ?? null,
            count: 1,
            timestamp: event.timestamp,
          });
        }
      }
      currentBatch = [];
      currentTool = null;
      currentAgent = null;
    };

    for (const event of logicalEvents) {
      const tool = event.tool ?? null;
      const agent = event.agentId ?? null;
      const isBatchable = tool !== null && BATCHABLE_TOOLS.includes(tool);

      if (isBatchable && tool === currentTool && agent === currentAgent) {
        // Continue current batch
        currentBatch.push(event);
      } else {
        // Flush previous batch and start new
        flushBatch();

        if (isBatchable) {
          // Start new batch
          currentBatch = [event];
          currentTool = tool;
          currentAgent = agent;
        } else {
          // Add as single (non-batchable tool)
          batched.push({
            id: event._id,
            type: "single",
            events: [event],
            tool: tool,
            agentId: agent,
            count: 1,
            timestamp: event.timestamp,
          });
        }
      }
    }

    // Flush final batch
    flushBatch();

    return batched;
  }, [events, filters]);
}
```

Key implementation details:
- Two-pass algorithm per CONTEXT.md
- toolUseId grouping happens BEFORE batching
- Only BATCHABLE_TOOLS are batched (read-heavy operations)
- Agent boundaries never crossed
- MIN_BATCH_SIZE = 2 per CONTEXT.md
  </action>
  <verify>TypeScript compiles without errors. Run `bun run lint` to check for issues.</verify>
  <done>useEventFilter returns URL-synced filter state. useBatchedEvents transforms events into BatchedEvent[] with proper toolUseId grouping and consecutive batching.</done>
</task>

<task type="auto">
  <name>Task 2: Create FilterBar component</name>
  <files>app/components/feed/FilterBar.tsx</files>
  <action>
Create the filter bar UI component per CONTEXT.md (floating filter bar below header):

```typescript
"use client";

import { useEventFilter } from "@/app/hooks/useEventFilter";

// Available tool types with their display colors
const TOOL_TYPES = [
  { value: "Read", label: "Read", color: "bg-green-500" },
  { value: "Write", label: "Write", color: "bg-blue-500" },
  { value: "Edit", label: "Edit", color: "bg-blue-400" },
  { value: "Bash", label: "Bash", color: "bg-orange-500" },
  { value: "Glob", label: "Glob", color: "bg-green-400" },
  { value: "Grep", label: "Grep", color: "bg-emerald-500" },
] as const;

interface FilterBarProps {
  /** Optional className for positioning */
  className?: string;
}

/**
 * Floating filter bar for event type filtering.
 * Filter state persists in URL (?filter=Read,Write).
 * Multi-select: click to toggle individual filters.
 */
export function FilterBar({ className = "" }: FilterBarProps) {
  const [filters, setFilters] = useEventFilter();

  const toggleFilter = (value: string) => {
    if (filters.includes(value)) {
      setFilters(filters.filter((f) => f !== value));
    } else {
      setFilters([...filters, value]);
    }
  };

  const clearFilters = () => setFilters([]);

  const hasActiveFilters = filters.length > 0;

  return (
    <div
      className={`flex items-center gap-2 px-4 py-2 bg-zinc-900/80 backdrop-blur-sm border-b border-zinc-800 ${className}`}
    >
      <span className="text-xs text-zinc-500 mr-1">Filter:</span>

      {TOOL_TYPES.map(({ value, label, color }) => {
        const isActive = filters.includes(value);
        return (
          <button
            key={value}
            onClick={() => toggleFilter(value)}
            className={`text-xs px-2 py-1 rounded transition-colors ${
              isActive
                ? `${color} text-white`
                : "bg-zinc-800 text-zinc-400 hover:bg-zinc-700 hover:text-zinc-300"
            }`}
            aria-pressed={isActive}
          >
            {label}
          </button>
        );
      })}

      {hasActiveFilters && (
        <button
          onClick={clearFilters}
          className="text-xs text-zinc-500 hover:text-zinc-300 ml-2 transition-colors"
        >
          Clear
        </button>
      )}
    </div>
  );
}
```

Key decisions:
- Multi-select filter (toggle individual types)
- URL persistence via useEventFilter hook
- Colors match existing EventCard border colors
- Clear button appears when filters active
- Backdrop blur for floating appearance
  </action>
  <verify>Component renders without errors. Open /live and verify FilterBar can be imported (even if not wired yet).</verify>
  <done>FilterBar component shows filter buttons with proper toggle behavior and URL persistence.</done>
</task>

</tasks>

<verification>
1. `bun run lint` passes
2. TypeScript compilation succeeds
3. useEventFilter hook returns [filters, setFilters] tuple
4. useBatchedEvents correctly groups toolUseId events and batches consecutive same-tool events
</verification>

<success_criteria>
- useEventFilter uses nuqs parseAsArrayOf for URL state
- useBatchedEvents implements two-pass algorithm (toolUseId grouping, then batching)
- FilterBar shows 6 tool types with toggle behavior
- Filter state syncs to URL (?filter=Read,Write)
</success_criteria>

<output>
After completion, create `.planning/phases/06-performance-scale/06-02-SUMMARY.md`
</output>
