---
phase: 06-performance-scale
plan: 03
type: execute
wave: 2
depends_on: ["06-01"]
files_modified:
  - app/hooks/useViewerCount.ts
  - app/hooks/usePageVisibility.ts
  - app/components/feed/BatchedEventGroup.tsx
autonomous: true

must_haves:
  truths:
    - "Viewer count updates in real-time as viewers join/leave"
    - "Only active tabs are counted as viewers"
    - "Batched events display as expandable groups showing count and file samples"
  artifacts:
    - path: "app/hooks/useViewerCount.ts"
      provides: "Real-time viewer count with presence heartbeats"
      exports: ["useViewerCount"]
    - path: "app/hooks/usePageVisibility.ts"
      provides: "Active tab detection"
      exports: ["usePageVisibility"]
    - path: "app/components/feed/BatchedEventGroup.tsx"
      provides: "Expandable batch display component"
      exports: ["BatchedEventGroup"]
  key_links:
    - from: "app/hooks/useViewerCount.ts"
      to: "convex/presence.ts"
      via: "useMutation and useQuery"
      pattern: "api\\.presence\\.(heartbeat|listViewers)"
    - from: "app/hooks/useViewerCount.ts"
      to: "app/hooks/usePageVisibility.ts"
      via: "visibility check before heartbeat"
      pattern: "isVisible.*heartbeat"
---

<objective>
Create the viewer count hook with active tab detection, and the BatchedEventGroup component for displaying batched events.

Purpose: Enable real-time viewer count display ("5 watching") and provide UI for expandable event batches.
Output: useViewerCount hook that tracks and displays viewers, BatchedEventGroup component for batched events.
</objective>

<execution_context>
@/Users/alexander.buss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexander.buss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-performance-scale/06-CONTEXT.md
@.planning/phases/06-performance-scale/06-RESEARCH.md
@.planning/phases/06-performance-scale/06-01-SUMMARY.md
@convex/presence.ts
@app/components/feed/EventCard.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create viewer count and page visibility hooks</name>
  <files>app/hooks/usePageVisibility.ts, app/hooks/useViewerCount.ts</files>
  <action>
**app/hooks/usePageVisibility.ts:**
Create a hook for detecting active tab state:

```typescript
"use client";

import { useState, useEffect } from "react";

/**
 * Track whether the current tab is visible/active.
 * Uses Page Visibility API to detect tab switches, minimize, etc.
 *
 * Per CONTEXT.md: "Watching" = active tab only
 */
export function usePageVisibility(): boolean {
  const [isVisible, setIsVisible] = useState(true);

  useEffect(() => {
    // Initial state
    setIsVisible(document.visibilityState === "visible");

    const handleVisibilityChange = () => {
      setIsVisible(document.visibilityState === "visible");
    };

    document.addEventListener("visibilitychange", handleVisibilityChange);
    return () => {
      document.removeEventListener("visibilitychange", handleVisibilityChange);
    };
  }, []);

  return isVisible;
}
```

**app/hooks/useViewerCount.ts:**
Create the main viewer count hook using Convex presence:

```typescript
"use client";

import { useQuery, useMutation } from "convex/react";
import { api } from "@/convex/_generated/api";
import { useEffect, useRef } from "react";
import { usePageVisibility } from "./usePageVisibility";

// Heartbeat interval in ms (5 seconds)
const HEARTBEAT_INTERVAL = 5000;

/**
 * Track and display real-time viewer count for a room.
 *
 * Per CONTEXT.md decisions:
 * - Only sends heartbeats when tab is visible
 * - Returns count of active viewers
 * - Uses anonymous viewer IDs (no auth required)
 *
 * @param room - Room identifier (e.g., "projectName" or "projectName:sessionId")
 * @returns Number of active viewers (0 if room is null/undefined)
 */
export function useViewerCount(room: string | null | undefined): number {
  const isVisible = usePageVisibility();
  const heartbeat = useMutation(api.presence.heartbeat);

  // Store stable viewer ID per browser session
  const viewerIdRef = useRef<string | null>(null);

  // Query viewers for the room
  const viewers = useQuery(
    api.presence.listViewers,
    room ? { room } : "skip"
  );

  // Send heartbeats only when tab is visible
  useEffect(() => {
    if (!room || !isVisible) return;

    // Generate viewer ID once per session
    if (!viewerIdRef.current) {
      viewerIdRef.current = `viewer-${Date.now()}-${Math.random().toString(36).slice(2, 9)}`;
    }

    const sendHeartbeat = () => {
      heartbeat({ room }).catch(() => {
        // Silently ignore heartbeat errors (network issues, etc.)
      });
    };

    // Send initial heartbeat
    sendHeartbeat();

    // Set up interval
    const interval = setInterval(sendHeartbeat, HEARTBEAT_INTERVAL);

    return () => {
      clearInterval(interval);
    };
  }, [room, isVisible, heartbeat]);

  return viewers?.length ?? 0;
}
```

Key implementation details per CONTEXT.md and RESEARCH.md:
- Only counts visible tabs (Page Visibility API)
- 5-second heartbeat interval with 10-second TTL (from 06-01)
- Anonymous viewer IDs (no authentication)
- Graceful error handling for heartbeat failures
  </action>
  <verify>TypeScript compiles. Run `bun run lint` to verify no issues.</verify>
  <done>usePageVisibility returns boolean for tab visibility. useViewerCount returns real-time viewer count and only sends heartbeats when tab is visible.</done>
</task>

<task type="auto">
  <name>Task 2: Create BatchedEventGroup component</name>
  <files>app/components/feed/BatchedEventGroup.tsx</files>
  <action>
Create the expandable batch display component:

```typescript
"use client";

import { useState } from "react";
import { useCollapse } from "react-collapsed";
import { ChevronRight, File } from "lucide-react";
import type { Doc } from "@/convex/_generated/dataModel";
import { useRelativeTime } from "./hooks/useRelativeTime";

type Event = Doc<"events">;

interface BatchedEventGroupProps {
  /** Tool type (Read, Glob, etc.) */
  tool: string;
  /** All events in this batch */
  events: Event[];
  /** Number of events */
  count: number;
  /** Whether this batch should animate as new */
  isNew?: boolean;
}

// Tool type to border color mapping (matches EventCard)
const TOOL_COLORS: Record<string, string> = {
  Read: "border-l-green-500",
  Glob: "border-l-green-400",
  Grep: "border-l-emerald-500",
  Write: "border-l-blue-500",
  Edit: "border-l-blue-400",
  Bash: "border-l-orange-500",
  WebSearch: "border-l-purple-500",
  WebFetch: "border-l-purple-400",
};

/**
 * Extract file path from event toolInput.
 * Handles various input structures.
 */
function extractFilePath(event: Event): string | null {
  const input = event.toolInput as Record<string, unknown> | null;
  if (!input) return null;

  // Common patterns
  if (typeof input.file_path === "string") return input.file_path;
  if (typeof input.path === "string") return input.path;
  if (typeof input.pattern === "string") return input.pattern;

  return null;
}

/**
 * Get short filename from full path.
 * Uses middle truncation for long paths: "src/.../file.tsx"
 */
function getShortPath(fullPath: string): string {
  const parts = fullPath.split("/");
  if (parts.length <= 2) return fullPath;

  const filename = parts[parts.length - 1];
  const parent = parts[parts.length - 2];

  if (fullPath.length > 40) {
    return `${parts[0]}/.../${parent}/${filename}`;
  }
  return fullPath;
}

/**
 * Collapsible group for batched events.
 * Shows count and sample file paths, expands to show all events.
 */
export function BatchedEventGroup({
  tool,
  events,
  count,
  isNew = false,
}: BatchedEventGroupProps) {
  const [isExpanded, setIsExpanded] = useState(false);
  const { getCollapseProps, getToggleProps } = useCollapse({
    isExpanded,
    duration: 200,
    easing: "cubic-bezier(0.4, 0, 0.2, 1)",
  });

  // Get timestamp from first event
  const timestamp = events[0]?.timestamp ?? Date.now();
  const relativeTime = useRelativeTime(timestamp);

  // Extract sample file paths for preview (first 3)
  const samplePaths = events
    .slice(0, 3)
    .map(extractFilePath)
    .filter((p): p is string => p !== null)
    .map((p) => p.split("/").pop() ?? p);

  const borderColor = TOOL_COLORS[tool] ?? "border-l-zinc-500";

  return (
    <div
      className={`border-l-4 ${borderColor} bg-zinc-900/50 rounded-r ${
        isNew ? "animate-fade-in" : ""
      }`}
    >
      {/* Collapsed header - clickable to expand */}
      <button
        {...getToggleProps({ onClick: () => setIsExpanded(!isExpanded) })}
        className="w-full px-3 py-2 flex items-center justify-between hover:bg-zinc-900/70 transition-colors text-left"
      >
        <div className="flex items-center gap-2 min-w-0">
          {/* Expand indicator */}
          <ChevronRight
            className={`w-4 h-4 text-zinc-500 transition-transform flex-shrink-0 ${
              isExpanded ? "rotate-90" : ""
            }`}
          />

          {/* Tool name */}
          <span className="font-mono text-sm text-zinc-300">{tool}</span>

          {/* Count badge */}
          <span className="text-xs bg-zinc-800 text-zinc-400 px-1.5 py-0.5 rounded flex-shrink-0">
            {count} files
          </span>

          {/* Sample file names */}
          <span className="text-xs text-zinc-500 truncate">
            {samplePaths.join(", ")}
            {count > 3 && "..."}
          </span>
        </div>

        {/* Timestamp */}
        <span className="text-xs text-zinc-600 flex-shrink-0 ml-2">
          {relativeTime}
        </span>
      </button>

      {/* Expanded content - list of all files */}
      <div {...getCollapseProps()}>
        <div className="px-3 pb-2 space-y-1 border-t border-zinc-800/50">
          {events.map((event) => {
            const filePath = extractFilePath(event);
            return (
              <div
                key={event._id}
                className="flex items-center gap-2 text-xs text-zinc-400 pl-6 py-1"
              >
                <File className="w-3 h-3 text-zinc-600 flex-shrink-0" />
                <span className="font-mono truncate">
                  {filePath ? getShortPath(filePath) : event.type}
                </span>
              </div>
            );
          })}
        </div>
      </div>
    </div>
  );
}
```

Key implementation details per CONTEXT.md:
- Shows "count + sample" format (e.g., "Read | 15 files | App.tsx, Header.tsx...")
- Expandable to show all file paths
- Uses react-collapsed for smooth animation (200ms, cubic-bezier)
- Matches EventCard styling (border colors, hover states)
- Uses lucide-react icons (already installed)
  </action>
  <verify>Component renders without errors. Import into EventFeed temporarily to verify it displays correctly.</verify>
  <done>BatchedEventGroup shows collapsed view with count and sample files, expands to show all files in batch.</done>
</task>

</tasks>

<verification>
1. `bun run lint` passes
2. TypeScript compilation succeeds
3. usePageVisibility correctly detects tab visibility changes
4. useViewerCount returns viewer count and respects tab visibility
5. BatchedEventGroup expands/collapses with file list
</verification>

<success_criteria>
- usePageVisibility uses Page Visibility API correctly
- useViewerCount only sends heartbeats when tab visible
- useViewerCount returns real-time count from Convex presence
- BatchedEventGroup shows tool, count, sample files in collapsed state
- BatchedEventGroup expands to show all file paths
</success_criteria>

<output>
After completion, create `.planning/phases/06-performance-scale/06-03-SUMMARY.md`
</output>
