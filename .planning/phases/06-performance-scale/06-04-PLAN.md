---
phase: 06-performance-scale
plan: 04
type: execute
wave: 3
depends_on: ["06-02", "06-03"]
files_modified:
  - app/components/feed/EventFeed.tsx
  - app/components/ui/Header.tsx
  - app/live/LiveFeedContent.tsx
autonomous: false

must_haves:
  truths:
    - "Feed virtualizes 100+ events without performance degradation"
    - "Batched events display as expandable groups in the feed"
    - "Filter bar filters events by type"
    - "Viewer count displays in header"
  artifacts:
    - path: "app/components/feed/EventFeed.tsx"
      provides: "Virtualized feed with batching and filtering"
      contains: "useVirtualizer"
    - path: "app/components/ui/Header.tsx"
      provides: "Header with viewer count"
      contains: "watching"
    - path: "app/live/LiveFeedContent.tsx"
      provides: "Integrated live feed page"
      contains: "FilterBar"
  key_links:
    - from: "app/components/feed/EventFeed.tsx"
      to: "app/hooks/useBatchedEvents.ts"
      via: "batching transformation"
      pattern: "useBatchedEvents"
    - from: "app/components/feed/EventFeed.tsx"
      to: "@tanstack/react-virtual"
      via: "list virtualization"
      pattern: "useVirtualizer"
    - from: "app/components/feed/EventFeed.tsx"
      to: "app/components/feed/BatchedEventGroup.tsx"
      via: "batch rendering"
      pattern: "BatchedEventGroup"
    - from: "app/components/ui/Header.tsx"
      to: "app/hooks/useViewerCount.ts"
      via: "viewer count display"
      pattern: "useViewerCount"
---

<objective>
Integrate virtualization, batching, filtering, and viewer count into the live feed.

Purpose: Complete Phase 6 by wiring all components together for a performant, feature-complete feed.
Output: Virtualized EventFeed with batching, FilterBar integration, and viewer count in Header.
</objective>

<execution_context>
@/Users/alexander.buss/.claude/get-shit-done/workflows/execute-plan.md
@/Users/alexander.buss/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/phases/06-performance-scale/06-CONTEXT.md
@.planning/phases/06-performance-scale/06-RESEARCH.md
@.planning/phases/06-performance-scale/06-02-SUMMARY.md
@.planning/phases/06-performance-scale/06-03-SUMMARY.md
@app/components/feed/EventFeed.tsx
@app/components/ui/Header.tsx
@app/live/LiveFeedContent.tsx
@app/hooks/useBatchedEvents.ts
@app/hooks/useEventFilter.ts
@app/hooks/useViewerCount.ts
@app/components/feed/BatchedEventGroup.tsx
@app/components/feed/FilterBar.tsx
</context>

<tasks>

<task type="auto">
  <name>Task 1: Integrate virtualization and batching into EventFeed</name>
  <files>app/components/feed/EventFeed.tsx</files>
  <action>
Update EventFeed to use virtualization and batching:

Key changes:
1. Import and use `useVirtualizer` from @tanstack/react-virtual
2. Import and use `useBatchedEvents` for event transformation
3. Import and use `useEventFilter` for filtering
4. Import `BatchedEventGroup` from "./BatchedEventGroup"
5. Render `BatchedEventGroup` for batched events, `EventCard` for singles
6. Use `measureElement` for variable height support

Important implementation notes from RESEARCH.md:
- Set `estimateSize` to ~48px (collapsed card height)
- Use `overscan: 5` for smooth scrolling
- Pass `measureElement` ref to each item for dynamic heights
- Handle expand/collapse re-measurement

Structure:
```typescript
// At top of file, add imports:
import { useRef } from "react";
import { useVirtualizer } from "@tanstack/react-virtual";
import { useBatchedEvents, type BatchedEvent } from "@/app/hooks/useBatchedEvents";
import { useEventFilter } from "@/app/hooks/useEventFilter";
import { BatchedEventGroup } from "./BatchedEventGroup";

// In component, after useQuery for events:
const [filters] = useEventFilter();
const batchedEvents = useBatchedEvents(events, filters);

// Replace the event list rendering with virtualized version:
const parentRef = useRef<HTMLDivElement>(null);

const virtualizer = useVirtualizer({
  count: batchedEvents.length,
  getScrollElement: () => parentRef.current,
  estimateSize: () => 48, // Estimated collapsed height
  overscan: 5,
});

// In JSX, replace the events.map with:
<div
  ref={parentRef}
  className="flex-1 overflow-y-auto px-4 py-2"
>
  <div
    style={{
      height: `${virtualizer.getTotalSize()}px`,
      width: "100%",
      position: "relative",
    }}
  >
    {virtualizer.getVirtualItems().map((virtualRow) => {
      const item = batchedEvents[virtualRow.index];
      return (
        <div
          key={item.id}
          data-index={virtualRow.index}
          ref={virtualizer.measureElement}
          style={{
            position: "absolute",
            top: 0,
            left: 0,
            width: "100%",
            transform: `translateY(${virtualRow.start}px)`,
          }}
        >
          {item.type === "batch" ? (
            <BatchedEventGroup
              tool={item.tool!}
              events={item.events}
              count={item.count}
              isNew={hasInitialLoad && !initialEventIds.has(item.id)}
            />
          ) : (
            <EventCard
              event={item.events[0]}
              isNew={hasInitialLoad && !initialEventIds.has(item.id)}
              isExpanded={isExpanded(item.id)}
              onToggle={() => toggle(item.id)}
            />
          )}
        </div>
      );
    })}
  </div>
</div>
```

Update initial event tracking to use batched event IDs:
- Track initialEventIds from batchedEvents, not raw events
- This ensures new batches animate correctly

Keep existing features:
- SessionHeader for selected sessions
- CurrentlyIndicator for latest activity
- NewEventsIndicator for scroll-to-top
- Loading and empty states

Note: The useNewEventsIndicator hook needs to work with the virtualized container. Update containerRef to use parentRef.
  </action>
  <verify>Run `bun dev` and `bunx convex dev`. Open /live, verify events render in virtualized list. Scroll through 50+ events smoothly. Verify batched events appear as collapsible groups.</verify>
  <done>EventFeed uses virtualization for smooth 100+ event scrolling. Batched events display as BatchedEventGroup. Filters apply via useBatchedEvents.</done>
</task>

<task type="auto">
  <name>Task 2: Add viewer count to Header and FilterBar to LiveFeedContent</name>
  <files>app/components/ui/Header.tsx, app/live/LiveFeedContent.tsx</files>
  <action>
**app/components/ui/Header.tsx:**
Add viewer count display:

```typescript
// Add imports:
import { useViewerCount } from "@/app/hooks/useViewerCount";
import { useProjectFilter } from "@/app/hooks/useProjectFilter";
import { Eye } from "lucide-react";

// Add props:
interface HeaderProps {
  onExpandAll?: () => void;
  onCollapseAll?: () => void;
  /** Room for viewer count (projectName or projectName:sessionId) */
  viewerRoom?: string | null;
}

// In component:
export function Header({ onExpandAll, onCollapseAll, viewerRoom }: HeaderProps) {
  const viewerCount = useViewerCount(viewerRoom);

  // In JSX, add viewer count after ConnectionStatus:
  <div className="flex items-center gap-3">
    <h1 className="text-lg font-bold text-zinc-100">agentstype.dev</h1>
    <ConnectionStatus />
    {viewerCount > 0 && (
      <div className="flex items-center gap-1 text-xs text-zinc-500">
        <Eye className="w-3 h-3" />
        <span>{viewerCount} watching</span>
      </div>
    )}
  </div>
```

**app/live/LiveFeedContent.tsx:**
Add FilterBar and pass viewerRoom to Header:

```typescript
// Add imports:
import { FilterBar } from "@/app/components/feed/FilterBar";
import { useProjectFilter } from "@/app/hooks/useProjectFilter";
import { useSessionFilter } from "@/app/hooks/useSessionFilter";

// In component, get room for viewer count:
const [selectedProject] = useProjectFilter();
const [selectedSession] = useSessionFilter();

// Compute viewer room - use session if selected, otherwise project
const viewerRoom = selectedSession
  ? `${selectedProject}:${selectedSession}`
  : selectedProject;

// In JSX:
// 1. Pass viewerRoom to Header:
<Header
  onExpandAll={expandCollapseHandlers?.expandAll}
  onCollapseAll={expandCollapseHandlers?.collapseAll}
  viewerRoom={viewerRoom}
/>

// 2. Add FilterBar below Header, above the main content:
<FilterBar />

// Full structure:
<main className="flex-1 flex flex-col overflow-hidden">
  <Header
    onExpandAll={expandCollapseHandlers?.expandAll}
    onCollapseAll={expandCollapseHandlers?.collapseAll}
    viewerRoom={viewerRoom}
  />
  <FilterBar />
  <div className="flex-1 flex overflow-hidden">
    {/* sidebar and feed */}
  </div>
</main>
```

Key decisions:
- Viewer count shows after ConnectionStatus with eye icon
- Only shows if viewerCount > 0 (no "0 watching")
- FilterBar is sticky below Header
- Room is project-scoped or session-scoped based on selection
  </action>
  <verify>Run `bun dev`. Open /live in two browser tabs. Verify viewer count shows "2 watching" (or similar). Verify FilterBar appears and toggles filter events.</verify>
  <done>Header shows viewer count. FilterBar appears below header. Clicking filter buttons updates URL and filters displayed events.</done>
</task>

<task type="checkpoint:human-verify" gate="blocking">
  <what-built>
Complete Phase 6 integration:
- Virtualized event feed handling 100+ events
- Event batching ("Read 15 files" expandable)
- Event type filtering via FilterBar
- Real-time viewer count in header
  </what-built>
  <how-to-verify>
1. Open http://localhost:3000/live in two browser tabs
2. Verify viewer count shows "2 watching" in header
3. Generate 20+ events (or use existing data)
4. Verify events scroll smoothly
5. Look for batched events (consecutive Reads should show "Read | X files")
6. Click a batch to expand and see individual files
7. Click filter buttons (Read, Write, Bash)
8. Verify feed updates to show only filtered events
9. Verify filter persists in URL (?filter=Read,Write)
10. Switch to different project/session, verify viewer room updates
  </how-to-verify>
  <resume-signal>Type "approved" or describe issues found</resume-signal>
</task>

</tasks>

<verification>
1. Virtualized feed renders without layout issues
2. Scroll performance is smooth with 100+ events
3. Batched events expand/collapse correctly
4. Filters update URL and filter displayed events
5. Viewer count updates in real-time across tabs
</verification>

<success_criteria>
- EventFeed uses @tanstack/react-virtual for rendering
- Batched events display as BatchedEventGroup components
- FilterBar filters events by type
- Viewer count displays in Header when > 0
- All Phase 6 requirements (PERF-01, PERF-02, PERF-03, SOCL-01) are met
</success_criteria>

<output>
After completion, create `.planning/phases/06-performance-scale/06-04-SUMMARY.md`
</output>
